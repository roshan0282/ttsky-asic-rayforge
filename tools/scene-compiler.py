#!/usr/bin/env python3
"""Scene compiler: JSON -> SystemVerilog LUT header (Q8.4) with spheres and lights."""

from __future__ import annotations

import argparse
import json
from pathlib import Path

qFrac = 4
qScale = 1 << qFrac
qMin = -(1 << 11)
qMax = (1 << 11) - 1


def toQ84(value: float) -> int:
    qValue = int(round(value * qScale))
    if qValue < qMin:
        qValue = qMin
    if qValue > qMax:
        qValue = qMax
    return qValue


def compileScene(sceneData: dict) -> str:
    spheres = sceneData.get("spheres", [])
    lights = sceneData.get("lights", [])

    lines: list[str] = []
    lines.append("// Auto-generated by tools/scene-compiler.py")
    lines.append(f"localparam int SCENE_SPHERE_COUNT = {len(spheres)};")
    lines.append(f"localparam int SCENE_LIGHT_COUNT = {len(lights)};")
    lines.append("")

    lines.append("function automatic void sceneSphereGet(")
    lines.append("    input  logic [7:0] idx,")
    lines.append("    output logic signed [11:0] cx,")
    lines.append("    output logic signed [11:0] cy,")
    lines.append("    output logic signed [11:0] cz,")
    lines.append("    output logic signed [11:0] radius,")
    lines.append("    output logic [7:0] colorR,")
    lines.append("    output logic [7:0] colorG,")
    lines.append("    output logic [7:0] colorB,")
    lines.append("    output logic signed [11:0] reflectivity")
    lines.append(");")
    lines.append("begin")
    lines.append("    unique case (idx)")

    for sphereIndex, sphere in enumerate(spheres):
        centerX, centerY, centerZ = sphere["center"]
        sphereRadius = sphere["radius"]
        colorR, colorG, colorB = sphere.get("color", [255, 255, 255])
        sphereReflectivity = sphere.get("reflectivity", 0.0)

        lines.append(f"        8'd{sphereIndex}: begin")
        lines.append(f"            cx = 12'sd{toQ84(float(centerX))};")
        lines.append(f"            cy = 12'sd{toQ84(float(centerY))};")
        lines.append(f"            cz = 12'sd{toQ84(float(centerZ))};")
        lines.append(f"            radius = 12'sd{toQ84(float(sphereRadius))};")
        lines.append(f"            colorR = 8'd{int(colorR) & 0xFF};")
        lines.append(f"            colorG = 8'd{int(colorG) & 0xFF};")
        lines.append(f"            colorB = 8'd{int(colorB) & 0xFF};")
        lines.append(f"            reflectivity = 12'sd{toQ84(float(sphereReflectivity))};")
        lines.append("        end")

    lines.append("        default: begin")
    lines.append("            cx = '0; cy = '0; cz = '0; radius = '0;")
    lines.append("            colorR = '0; colorG = '0; colorB = '0;")
    lines.append("            reflectivity = '0;")
    lines.append("        end")
    lines.append("    endcase")
    lines.append("end")
    lines.append("endfunction")
    lines.append("")

    lines.append("function automatic void sceneLightGet(")
    lines.append("    input  logic [7:0] idx,")
    lines.append("    output logic signed [11:0] lx,")
    lines.append("    output logic signed [11:0] ly,")
    lines.append("    output logic signed [11:0] lz,")
    lines.append("    output logic [7:0] colorR,")
    lines.append("    output logic [7:0] colorG,")
    lines.append("    output logic [7:0] colorB,")
    lines.append("    output logic signed [11:0] intensity")
    lines.append(");")
    lines.append("begin")
    lines.append("    unique case (idx)")

    for lightIndex, light in enumerate(lights):
        lightX, lightY, lightZ = light["position"]
        lightColorR, lightColorG, lightColorB = light.get("color", [255, 255, 255])
        lightIntensity = light.get("intensity", 1.0)

        lines.append(f"        8'd{lightIndex}: begin")
        lines.append(f"            lx = 12'sd{toQ84(float(lightX))};")
        lines.append(f"            ly = 12'sd{toQ84(float(lightY))};")
        lines.append(f"            lz = 12'sd{toQ84(float(lightZ))};")
        lines.append(f"            colorR = 8'd{int(lightColorR) & 0xFF};")
        lines.append(f"            colorG = 8'd{int(lightColorG) & 0xFF};")
        lines.append(f"            colorB = 8'd{int(lightColorB) & 0xFF};")
        lines.append(f"            intensity = 12'sd{toQ84(float(lightIntensity))};")
        lines.append("        end")

    lines.append("        default: begin")
    lines.append("            lx = '0; ly = '0; lz = '0;")
    lines.append("            colorR = '0; colorG = '0; colorB = '0;")
    lines.append("            intensity = '0;")
    lines.append("        end")
    lines.append("    endcase")
    lines.append("end")
    lines.append("endfunction")
    lines.append("")

    return "\n".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser(description="Compile scene JSON to SV LUT header")
    parser.add_argument("--in", dest="inputPath", required=True, help="Input scene JSON")
    parser.add_argument("--out", dest="outputPath", required=True, help="Output scene-lut.svh")
    args = parser.parse_args()

    inputPath = Path(args.inputPath)
    outputPath = Path(args.outputPath)

    sceneData = json.loads(inputPath.read_text(encoding="utf-8"))
    svText = compileScene(sceneData)

    outputPath.parent.mkdir(parents=True, exist_ok=True)
    outputPath.write_text(svText, encoding="utf-8")


if __name__ == "__main__":
    main()
