// ─────────────────────────────────────────────────────────────────────────────
// raytracer_simple.sv  —  Simple single-bounce raytracer (Q16.16)
//
// State machine based design with explicit cycle control:
//  - IDLE: Wait for valid pixel
//  - INTERSECT: Calculate ray-sphere intersections (1 cycle)
//  - SHADE: Calculate shading (1 cycle)  
//  - OUTPUT: Write result (1 cycle)
//
// Total: 3 cycles per pixel
// ─────────────────────────────────────────────────────────────────────────────

`timescale 1ns/1ps
`default_nettype none

import scene_lut::*;

module raytracer_simple (
    input  logic        clk,
    input  logic        rst_n,
    
    input  logic [9:0]  pixel_x,
    input  logic [8:0]  pixel_y,
    input  logic        pixel_valid,
    
    output logic [7:0]  rgb_r,
    output logic [7:0]  rgb_g,
    output logic [7:0]  rgb_b,
    output logic        output_valid
);

    // ── State machine ─────────────────────────────────────────────────────────
    typedef enum logic [1:0] {
        IDLE      = 2'd0,
        INTERSECT = 2'd1,
        SHADE     = 2'd2,
        OUTPUT    = 2'd3
    } state_t;
    
    state_t state, next_state;
    
    // Pixel coordinates
    logic [9:0] px;
    logic [8:0] py;
    // Matches C++: rawDx = (px - 320) << 14, rawDy = (240 - py) << 14, rawDz = 100 << 16
    logic signed [31:0] centered_x, centered_y;
    logic signed [31:0] raw_dx, raw_dy, raw_dz;
    logic signed [31:0] norm_dx, norm_dy, norm_dz;
    
    always_comb begin
        // Convert to signed first, then subtract to avoid unsigned intermediate
        centered_x = 32'sd0 + $signed({22'd0, pixel_x}) - 32'sd320;
        centered_y = 32'sd0 + 32'sd240 - $signed({23'd0, pixel_y});
        
        raw_dx = centered_x <<< 14;  // Q16.16
        raw_dy = centered_y <<< 14;
        raw_dz = 32'sd6553600;  // 100 << 16
    end
    
    vec3_normalize u_camera_norm (
        .x(raw_dx), .y(raw_dy), .z(raw_dz),
        .nx(norm_dx), .ny(norm_dy), .nz(norm_dz)
    );
    
    // ── Parallel intersection with all 3 spheres ──────────────────────────────
    logic        hit_arr [0:2];
    logic signed [31:0] t_arr [0:2];
    logic signed [31:0] cx_arr [0:2];
    logic signed [31:0] cy_arr [0:2];
    logic signed [31:0] cz_arr [0:2];
    logic signed [31:0] radius_arr [0:2];
    logic [7:0]  colorR_arr [0:2];
    logic [7:0]  colorG_arr [0:2];
    logic [7:0]  colorB_arr [0:2];
    logic signed [31:0] refl_arr [0:2];
    
    // Get scene data
    always_comb begin
        getSphere0(cx_arr[0], cy_arr[0], cz_arr[0], radius_arr[0],
                             colorR_arr[0], colorG_arr[0], colorB_arr[0], refl_arr[0]);
        getSphere1(cx_arr[1], cy_arr[1], cz_arr[1], radius_arr[1],
                             colorR_arr[1], colorG_arr[1], colorB_arr[1], refl_arr[1]);
        getSphere2(cx_arr[2], cy_arr[2], cz_arr[2], radius_arr[2],
                             colorR_arr[2], colorG_arr[2], colorB_arr[2], refl_arr[2]);
    end
    
    // Test all spheres in parallel
    genvar i;
    generate
        for (i = 0; i < 3; i++) begin : g_sphere
            ray_sphere_intersect u_intersect (
                .ox(32'sd0), .oy(32'sd0), .oz(32'sd0),  // Camera at origin
                .dx(norm_dx), .dy(norm_dy), .dz(norm_dz),
                .cx(cx_arr[i]), .cy(cy_arr[i]), .cz(cz_arr[i]),
                .radius(radius_arr[i]),
                .hit(hit_arr[i]),
                .t(t_arr[i])
            );
        end
    endgenerate
    
    // ── Find nearest hit ──────────────────────────────────────────────────────
    logic        nearest_hit_comb;
    logic signed [31:0] nearest_t_comb;
    logic signed [31:0] nearest_cx_comb, nearest_cy_comb, nearest_cz_comb;
    logic [7:0]  nearest_colorR_comb, nearest_colorG_comb, nearest_colorB_comb;
    
    always_comb begin
        nearest_hit_comb = 1'b0;
        nearest_t_comb = 32'sd2147483647;  // Max
        nearest_cx_comb = 32'sd0;
        nearest_cy_comb = 32'sd0;
        nearest_cz_comb = 32'sd0;
        nearest_colorR_comb = 8'd0;
        nearest_colorG_comb = 8'd0;
        nearest_colorB_comb = 8'd32;  // Background blue
        
        for (int j = 0; j < 3; j++) begin
            if (hit_arr[j] && t_arr[j] > 32'sd0) begin
                if (!nearest_hit_comb || t_arr[j] < nearest_t_comb) begin
                    nearest_hit_comb = 1'b1;
                    nearest_t_comb = t_arr[j];
                    nearest_cx_comb = cx_arr[j];
                    nearest_cy_comb = cy_arr[j];
                    nearest_cz_comb = cz_arr[j];
                    nearest_colorR_comb = colorR_arr[j];
                    nearest_colorG_comb = colorG_arr[j];
                    nearest_colorB_comb = colorB_arr[j];
                end
            end
        end
    end
    
    // ── Pipeline stage 1 ──────────────────────────────────────────────────────
    logic        s1_hit;
    logic signed [31:0] s1_t;
    logic signed [31:0] s1_cx, s1_cy, s1_cz;
    logic signed [31:0] s1_norm_dx, s1_norm_dy, s1_norm_dz;
    logic [7:0]  s1_colorR, s1_colorG, s1_colorB;
    logic        s1_valid;
    
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            s1_hit <= 1'b0;
            s1_t <= 32'sd0;
            s1_cx <= 32'sd0;
            s1_cy <= 32'sd0;
            s1_cz <= 32'sd0;
            s1_norm_dx <= 32'sd0;
            s1_norm_dy <= 32'sd0;
            s1_norm_dz <= 32'sd65536;
            s1_colorR <= 8'd0;
            s1_colorG <= 8'd0;
            s1_colorB <= 8'd32;
            s1_valid <= 1'b0;
        end else begin
            s1_hit <= nearest_hit_comb;
            s1_t <= nearest_t_comb;
            s1_cx <= nearest_cx_comb;
            s1_cy <= nearest_cy_comb;
            s1_cz <= nearest_cz_comb;
            s1_norm_dx <= norm_dx;
            s1_norm_dy <= norm_dy;
            s1_norm_dz <= norm_dz;
            s1_colorR <= nearest_colorR_comb;
            s1_colorG <= nearest_colorG_comb;
            s1_colorB <= nearest_colorB_comb;
            s1_valid <= pixel_valid;
        end
    end
    
    // ── Hit point and normal calculation ──────────────────────────────────────
    logic signed [31:0] hit_x, hit_y, hit_z;
    logic signed [31:0] norm_raw_x, norm_raw_y, norm_raw_z;
    logic signed [31:0] normal_x, normal_y, normal_z;
    
    // hitP = t * D  (origin is at 0,0,0)
    q16_mul u_hit_x (.a(s1_t), .b(s1_norm_dx), .prod(hit_x));
    q16_mul u_hit_y (.a(s1_t), .b(s1_norm_dy), .prod(hit_y));
    q16_mul u_hit_z (.a(s1_t), .b(s1_norm_dz), .prod(hit_z));
    
    // N_raw = hitP - C
    q16_sub u_norm_x (.a(hit_x), .b(s1_cx), .diff(norm_raw_x));
    q16_sub u_norm_y (.a(hit_y), .b(s1_cy), .diff(norm_raw_y));
    q16_sub u_norm_z (.a(hit_z), .b(s1_cz), .diff(norm_raw_z));
    
    vec3_normalize u_normal (
        .x(norm_raw_x), .y(norm_raw_y), .z(norm_raw_z),
        .nx(normal_x), .ny(normal_y), .nz(normal_z)
    );
    
    // ── Simple lighting (ambient + diffuse from light 0) ──────────────────────
    logic signed [31:0] light_x, light_y, light_z;
    logic [7:0] light_colorR, light_colorG, light_colorB;
    logic signed [31:0] light_intensity;
    
    always_comb begin
        getLight0(light_x, light_y, light_z,
                            light_colorR, light_colorG, light_colorB,
                            light_intensity);
    end
    
    // toLight = light_pos - hitP
    logic signed [31:0] to_light_x, to_light_y, to_light_z;
    q16_sub u_tl_x (.a(light_x), .b(hit_x), .diff(to_light_x));
    q16_sub u_tl_y (.a(light_y), .b(hit_y), .diff(to_light_y));
    q16_sub u_tl_z (.a(light_z), .b(hit_z), .diff(to_light_z));
    
    // Normalize to get light direction
    logic signed [31:0] ldir_x, ldir_y, ldir_z;
    vec3_normalize u_ldir (
        .x(to_light_x), .y(to_light_y), .z(to_light_z),
        .nx(ldir_x), .ny(ldir_y), .nz(ldir_z)
    );
    
    // N · L
    logic signed [31:0] ndotl;
    vec3_dot u_ndotl (
        .ax(normal_x), .ay(normal_y), .az(normal_z),
        .bx(ldir_x), .by(ldir_y), .bz(ldir_z),
        .dot(ndotl)
    );
    
    // ── Pipeline stage 2 ──────────────────────────────────────────────────────
    logic        s2_hit;
    logic [7:0]  s2_colorR, s2_colorG, s2_colorB;
    logic signed [31:0] s2_ndotl;
    logic        s2_valid;
    
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            s2_hit <= 1'b0;
            s2_colorR <= 8'd0;
            s2_colorG <= 8'd0;
            s2_colorB <= 8'd32;
            s2_ndotl <= 32'sd0;
            s2_valid <= 1'b0;
        end else begin
            s2_hit <= s1_hit;
            s2_colorR <= s1_colorR;
            s2_colorG <= s1_colorG;
            s2_colorB <= s1_colorB;
            s2_ndotl <= ndotl;
            s2_valid <= s1_valid;
        end
    end
    
    // ── Final shading calculation ─────────────────────────────────────────────
    logic [15:0] final_r, final_g, final_b;
    logic [7:0] ambient_r, ambient_g, ambient_b;
    logic signed [31:0] ndotl_clamped;
    logic [31:0] diffuse_r, diffuse_g, diffuse_b;
    
    always_comb begin
        // Initialize all variables to avoid latches
        final_r = 16'd0;
        final_g = 16'd0;
        final_b = 16'd32;
        ambient_r = 8'd0;
        ambient_g = 8'd0;
        ambient_b = 8'd0;
        ndotl_clamped = 32'sd0;
        diffuse_r = 32'd0;
        diffuse_g = 32'd0;
        diffuse_b = 32'd0;
        
        if (s2_hit) begin
            // Ambient (1/8 of base color)
            ambient_r = s2_colorR >>> 3;
            ambient_g = s2_colorG >>> 3;
            ambient_b = s2_colorB >>> 3;
            
            // Diffuse contribution if ndotl > 0
            if (s2_ndotl > 32'sd0) begin
                // Clamp ndotl to [0, 1] in Q16.16
                ndotl_clamped = (s2_ndotl > 32'sd65536) ? 32'sd65536 : s2_ndotl;
                
                // Multiply color by ndotl (Q16.16), keeping full precision
                diffuse_r = ({24'd0, s2_colorR} * ndotl_clamped) >>> 16;
                diffuse_g = ({24'd0, s2_colorG} * ndotl_clamped) >>> 16;
                diffuse_b = ({24'd0, s2_colorB} * ndotl_clamped) >>> 16;
                
                final_r = {8'd0, ambient_r} + diffuse_r[15:0];
                final_g = {8'd0, ambient_g} + diffuse_g[15:0];
                final_b = {8'd0, ambient_b} + diffuse_b[15:0];
            end else begin
                final_r = {8'd0, ambient_r};
                final_g = {8'd0, ambient_g};
                final_b = {8'd0, ambient_b};
            end
        end else begin
            // Background
            final_r = 16'd0;
            final_g = 16'd0;
            final_b = 16'd32;
        end
    end
    
    // ── Output stage ──────────────────────────────────────────────────────────
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rgb_r <= 8'd0;
            rgb_g <= 8'd0;
            rgb_b <= 8'd32;
        end else if (s2_valid) begin
            rgb_r <= (final_r > 16'd255) ? 8'd255 : final_r[7:0];
            rgb_g <= (final_g > 16'd255) ? 8'd255 : final_g[7:0];
            rgb_b <= (final_b > 16'd255) ? 8'd255 : final_b[7:0];
        end
    end

endmodule

`default_nettype wire
