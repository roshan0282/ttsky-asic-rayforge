// ─────────────────────────────────────────────────────────────────────────────
// raytracer_pipeline.sv  —  Per-pixel raytracing state machine
//
// Matches c-implementation/raytracer.h exactly
//
// Pipeline stages (per pixel):
//   1. Generate camera ray from pixel coordinates
//   2. Find nearest sphere hit
//   3. Shade hit point (shadow rays per light)
//   4. If reflective, prepare bounce ray
//   5. Repeat until MAX_ITERATIONS or no more bounces
//   6. Output accumulated RGB
//
// State machine approach required for hardware:
//   - No recursion → iterative loop with state tracking
//   - Time budget: MAX_ITERATIONS = 8 total ray tests per pixel
//   - Shadow rays: test occlusion for each light
//   - Multi-bounce: accumulate weighted color contributions
//
// Inputs:
//   - clk, rst_n
//   - pixel_x [9:0], pixel_y [8:0]  (0-639, 0-479)
//   - start_pixel (pulse to begin tracing this pixel)
//
// Outputs:
//   - rgb_r, rgb_g, rgb_b [7:0]
//   - pixel_done (pulse when pixel complete)
// ─────────────────────────────────────────────────────────────────────────────

`default_nettype none

module raytracer_pipeline (
    input  logic        clk,
    input  logic        rst_n,
    
    input  logic [9:0]  pixel_x,
    input  logic [8:0]  pixel_y,
    input  logic        start_pixel,
    
    output logic [7:0]  rgb_r,
    output logic [7:0]  rgb_g,
    output logic [7:0]  rgb_b,
    output logic        pixel_done
);

    // ── Configuration ─────────────────────────────────────────────────────────
    localparam MAX_ITERATIONS = 8;
    localparam NUM_SPHERES = 3;
    localparam NUM_LIGHTS  = 1;

    // ── State machine states ──────────────────────────────────────────────────
    typedef enum logic [3:0] {
        ST_IDLE,
        ST_GEN_RAY,
        ST_FIND_NEAREST,
        ST_SHADE_INIT,
        ST_SHADOW_TEST,
        ST_SHADE_ACCUM,
        ST_REFLECT_CHECK,
        ST_OUTPUT
    } state_t;

    state_t state, next_state;

    // ── Per-pixel working registers ───────────────────────────────────────────
    logic signed [31:0] ray_ox, ray_oy, ray_oz;
    logic signed [31:0] ray_dx, ray_dy, ray_dz;
    
    logic signed [31:0] hit_px, hit_py, hit_pz;
    logic signed [31:0] hit_nx, hit_ny, hit_nz;
    
    logic [2:0] bounce_count;
    logic [3:0] iter_count;
    logic [1:0] current_sphere_idx;
    logic [0:0] current_light_idx;
    
    logic signed [31:0] nearest_t;
    logic [1:0] nearest_idx;
    logic       nearest_hit;
    
    logic [7:0] sphere_colorR, sphere_colorG, sphere_colorB;
    logic signed [31:0] sphere_reflectivity;
    
    logic signed [15:0] accum_r, accum_g, accum_b;  // Accumulated color (16-bit)
    logic [4:0] weight;  // Q4.4 weight [0,16]
    
    logic signed [15:0] shade_r, shade_g, shade_b;  // Current shading
    logic in_shadow;

    // ── Camera ray generation ─────────────────────────────────────────────────
    logic signed [31:0] camera_rawdx, camera_rawdy, camera_rawdz;
    logic signed [31:0] camera_normdx, camera_normdy, camera_normdz;
    
    always_comb begin
        // centeredX = px - 320
        // centeredY = 240 - py
        logic signed [11:0] centeredX = $signed({2'b0, pixel_x}) - 12'sd320;
        logic signed [10:0] centeredY = 11'sd240 - $signed({2'b0, pixel_y});
        
        // rawDx = centeredX << 14  (Q16.16)
        camera_rawdx = $signed({{18{centeredX[11]}}, centeredX, 2'b0}) <<< 12;
        camera_rawdy = $signed({{19{centeredY[10]}}, centeredY, 2'b0}) <<< 12;
        camera_rawdz = 32'sd6553600;  // 100 << 16
    end
    
    vec3_normalize u_camera_norm (
        .x(camera_rawdx), .y(camera_rawdy), .z(camera_rawdz),
        .nx(camera_normdx), .ny(camera_normdy), .nz(camera_normdz)
    );

    // ── Scene LUT instantiation ───────────────────────────────────────────────
    logic signed [31:0] scene_cx, scene_cy, scene_cz, scene_radius;
    logic [7:0] scene_cR, scene_cG, scene_cB;
    logic signed [31:0] scene_refl;
    
    always_comb begin
        case (current_sphere_idx)
            2'd0: scene_lut::getSphere0(scene_cx, scene_cy, scene_cz, scene_radius,
                                        scene_cR, scene_cG, scene_cB, scene_refl);
            2'd1: scene_lut::getSphere1(scene_cx, scene_cy, scene_cz, scene_radius,
                                        scene_cR, scene_cG, scene_cB, scene_refl);
            2'd2: scene_lut::getSphere2(scene_cx, scene_cy, scene_cz, scene_radius,
                                        scene_cR, scene_cG, scene_cB, scene_refl);
            default: begin
                scene_cx = 0; scene_cy = 0; scene_cz = 0; scene_radius = 0;
                scene_cR = 0; scene_cG = 0; scene_cB = 0; scene_refl = 0;
            end
        endcase
    end
    
    logic signed [31:0] light_lx, light_ly, light_lz, light_intensity;
    logic [7:0] light_cR, light_cG, light_cB;
    
    always_comb begin
        // Only one light
        scene_lut::getLight0(light_lx, light_ly, light_lz,
                            light_cR, light_cG, light_cB, light_intensity);
    end

    // ── Ray-sphere intersection ───────────────────────────────────────────────
    logic signed [31:0] isect_t;
    logic isect_hit;
    
    ray_sphere_intersect u_intersect (
        .ox(ray_ox), .oy(ray_oy), .oz(ray_oz),
        .dx(ray_dx), .dy(ray_dy), .dz(ray_dz),
        .cx(scene_cx), .cy(scene_cy), .cz(scene_cz),
        .radius(scene_radius),
        .hit(isect_hit),
        .t(isect_t)
    );

    // ── Reflection direction R = D - 2(D·N)N ──────────────────────────────────
    logic signed [31:0] reflect_dx, reflect_dy, reflect_dz;
    logic signed [31:0] ndotn, two_ndotn;
    logic signed [31:0] proj_x, proj_y, proj_z;
    logic signed [31:0] refl_raw_x, refl_raw_y, refl_raw_z;
    
    vec3_dot u_ndotn (.ax(ray_dx), .ay(ray_dy), .az(ray_dz),
                      .bx(hit_nx), .by(hit_ny), .bz(hit_nz),
                      .dot(ndotn));
    
    q16_add u_two_ndotn (.a(ndotn), .b(ndotn), .sum(two_ndotn));
    
    vec3_scale u_proj (.x(hit_nx), .y(hit_ny), .z(hit_nz), .s(two_ndotn),
                       .rx(proj_x), .ry(proj_y), .rz(proj_z));
    
    vec3_sub u_refl_sub (.ax(ray_dx), .ay(ray_dy), .az(ray_dz),
                         .bx(proj_x), .by(proj_y), .bz(proj_z),
                         .rx(refl_raw_x), .ry(refl_raw_y), .rz(refl_raw_z));
    
    vec3_normalize u_refl_norm (.x(refl_raw_x), .y(refl_raw_y), .z(refl_raw_z),
                               .nx(reflect_dx), .ny(reflect_dy), .nz(reflect_dz));

    // ── State machine logic ───────────────────────────────────────────────────
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= ST_IDLE;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        next_state = state;
        
        case (state)
            ST_IDLE: begin
                if (start_pixel) next_state = ST_GEN_RAY;
            end
            
            ST_GEN_RAY: begin
                next_state = ST_FIND_NEAREST;
            end
            
            ST_FIND_NEAREST: begin
                // After testing all spheres
                if (current_sphere_idx == NUM_SPHERES - 1) begin
                    if (nearest_hit)
                        next_state = ST_SHADE_INIT;
                    else
                        next_state = ST_OUTPUT;  // Background hit
                end
            end
            
            ST_SHADE_INIT: begin
                next_state = ST_SHADOW_TEST;
            end
            
            ST_SHADOW_TEST: begin
                // After testing all spheres for shadows
                if (current_sphere_idx == NUM_SPHERES - 1) begin
                    next_state = ST_SHADE_ACCUM;
                end
            end
            
            ST_SHADE_ACCUM: begin
                if (current_light_idx == NUM_LIGHTS - 1)
                    next_state = ST_REFLECT_CHECK;
            end
            
            ST_REFLECT_CHECK: begin
                if (bounce_count >= 3 || iter_count >= MAX_ITERATIONS || weight < 5'd1)
                    next_state = ST_OUTPUT;
                else if (sphere_reflectivity > 32'sd9830)  // > 0.15
                    next_state = ST_GEN_RAY;  // Next bounce
                else
                    next_state = ST_OUTPUT;
            end
            
            ST_OUTPUT: begin
                next_state = ST_IDLE;
            end
        endcase
    end

    // ── Datapath logic ────────────────────────────────────────────────────────
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pixel_done <= 1'b0;
            rgb_r <= 8'd0;
            rgb_g <= 8'd0;
            rgb_b <= 8'd0;
            
            ray_ox <= 32'sd0;
            ray_oy <= 32'sd0;
            ray_oz <= 32'sd0;
            ray_dx <= 32'sd0;
            ray_dy <= 32'sd0;
            ray_dz <= 32'sd0;
            
            bounce_count <= 3'd0;
            iter_count <= 4'd0;
            current_sphere_idx <= 2'd0;
            current_light_idx <= 1'd0;
            
            nearest_t <= 32'sd0;
            nearest_idx <= 2'd0;
            nearest_hit <= 1'b0;
            
            accum_r <= 16'sd0;
            accum_g <= 16'sd0;
            accum_b <= 16'sd0;
            weight <= 5'd16;
            
            shade_r <= 16'sd0;
            shade_g <= 16'sd0;
            shade_b <= 16'sd0;
            in_shadow <= 1'b0;
            
        end else begin
            pixel_done <= 1'b0;  // Default
            
            case (state)
                ST_IDLE: begin
                    if (start_pixel) begin
                        // Initialize for new pixel
                        bounce_count <= 3'd0;
                        iter_count <= 4'd0;
                        accum_r <= 16'sd0;
                        accum_g <= 16'sd0;
                        accum_b <= 16'sd0;
                        weight <= 5'd16;
                        
                        ray_ox <= 32'sd0;
                        ray_oy <= 32'sd0;
                        ray_oz <= 32'sd0;
                    end
                end
                
                ST_GEN_RAY: begin
                    if (bounce_count == 3'd0) begin
                        // Primary ray from camera
                        ray_dx <= camera_normdx;
                        ray_dy <= camera_normdy;
                        ray_dz <= camera_normdz;
                    end else begin
                        // Reflected ray
                        ray_dx <= reflect_dx;
                        ray_dy <= reflect_dy;
                        ray_dz <= reflect_dz;
                        
                        // Offset origin slightly along normal (eps = 655 ≈ 0.01)
                        // hitP + eps * N
                        logic signed [31:0] eps_nx, eps_ny, eps_nz;
                        vec3_scale u_eps_scale (
                            .x(hit_nx), .y(hit_ny), .z(hit_nz),
                            .s(32'sd655),
                            .rx(eps_nx), .ry(eps_ny), .rz(eps_nz)
                        );
                        vec3_add u_offset (
                            .ax(hit_px), .ay(hit_py), .az(hit_pz),
                            .bx(eps_nx), .by(eps_ny), .bz(eps_nz),
                            .rx(ray_ox), .ry(ray_oy), .rz(ray_oz)
                        );
                    end
                    
                    current_sphere_idx <= 2'd0;
                    nearest_t <= 32'sd2147483647;  // Q16.16 max
                    nearest_hit <= 1'b0;
                    iter_count <= iter_count + 4'd1;
                end
                
                ST_FIND_NEAREST: begin
                    // Test intersection with current sphere
                    if (isect_hit && isect_t > 32'sd0) begin
                        if (!nearest_hit || isect_t < nearest_t) begin
                            nearest_t <= isect_t;
                            nearest_idx <= current_sphere_idx;
                            nearest_hit <= 1'b1;
                        end
                    end
                    
                    if (current_sphere_idx < NUM_SPHERES - 1) begin
                        current_sphere_idx <= current_sphere_idx + 2'd1;
                    end else begin
                        // Done finding nearest
                        if (!nearest_hit) begin
                            // Background — deep-space blue weighted by path
                            accum_r <= accum_r + (16'sd0  * $signed({11'd0, weight})) >>> 4;
                            accum_g <= accum_g + (16'sd0  * $signed({11'd0, weight})) >>> 4;
                            accum_b <= accum_b + (16'sd32 * $signed({11'd0, weight})) >>> 4;
                        end else begin
                            // Compute hit point and normal
                            // hitP = rayO + t * rayD
                            logic signed [31:0] scaled_dx, scaled_dy, scaled_dz;
                            vec3_scale u_hit_scale (
                                .x(ray_dx), .y(ray_dy), .z(ray_dz),
                                .s(nearest_t),
                                .rx(scaled_dx), .ry(scaled_dy), .rz(scaled_dz)
                            );
                            vec3_add u_hit_add (
                                .ax(ray_ox), .ay(ray_oy), .az(ray_oz),
                                .bx(scaled_dx), .by(scaled_dy), .bz(scaled_dz),
                                .rx(hit_px), .ry(hit_py), .rz(hit_pz)
                            );
                            
                            // Get sphere properties
                            current_sphere_idx <= nearest_idx;
                            // (wait one cycle for scene LUT)
                        end
                    end
                end
                
                ST_SHADE_INIT: begin
                    // Compute normal: N = normalize(hitP - C)
                    logic signed [31:0] norm_raw_x, norm_raw_y, norm_raw_z;
                    vec3_sub u_norm_sub (
                        .ax(hit_px), .ay(hit_py), .az(hit_pz),
                        .bx(scene_cx), .by(scene_cy), .bz(scene_cz),
                        .rx(norm_raw_x), .ry(norm_raw_y), .rz(norm_raw_z)
                    );
                    vec3_normalize u_norm_normalize (
                        .x(norm_raw_x), .y(norm_raw_y), .z(norm_raw_z),
                        .nx(hit_nx), .ny(hit_ny), .nz(hit_nz)
                    );
                    
                    // Store sphere color and reflectivity
                    sphere_colorR <= scene_cR;
                    sphere_colorG <= scene_cG;
                    sphere_colorB <= scene_cB;
                    sphere_reflectivity <= scene_refl;
                    
                    // Initialize shading (ambient)
                    shade_r <= {8'd0, scene_cR} >>> 3;
                    shade_g <= {8'd0, scene_cG} >>> 3;
                    shade_b <= {8'd0, scene_cB} >>> 3;
                    
                    current_light_idx <= 1'd0;
                    current_sphere_idx <= 2'd0;
                    in_shadow <= 1'b0;
                end
                
                ST_SHADOW_TEST: begin
                    // Test shadow ray against current sphere
                    // toLight = light_pos - hitP
                    logic signed [31:0] to_light_x, to_light_y, to_light_z;
                    vec3_sub u_to_light (
                        .ax(light_lx), .ay(light_ly), .az(light_lz),
                        .bx(hit_px), .by(hit_py), .bz(hit_pz),
                        .rx(to_light_x), .ry(to_light_y), .rz(to_light_z)
                    );
                    
                    // dist_to_light = sqrt(toLight · toLight)
                    logic signed [31:0] dist_sq, dist_to_light;
                    vec3_dot u_dist_dot (
                        .ax(to_light_x), .ay(to_light_y), .az(to_light_z),
                        .bx(to_light_x), .by(to_light_y), .bz(to_light_z),
                        .dot(dist_sq)
                    );
                    q16_sqrt u_dist_sqrt (.a(dist_sq), .root(dist_to_light));
                    
                    // lDir = normalize(toLight)
                    logic signed [31:0] ldir_x, ldir_y, ldir_z;
                    vec3_normalize u_ldir_norm (
                        .x(to_light_x), .y(to_light_y), .z(to_light_z),
                        .nx(ldir_x), .ny(ldir_y), .nz(ldir_z)
                    );
                    
                    // ndotl = N · lDir
                    logic signed [31:0] ndotl;
                    vec3_dot u_ndotl (
                        .ax(hit_nx), .ay(hit_ny), .az(hit_nz),
                        .bx(ldir_x), .by(ldir_y), .bz(ldir_z),
                        .dot(ndotl)
                    );
                    
                    if (ndotl > 32'sd0 && !in_shadow && iter_count < MAX_ITERATIONS) begin
                        // Shadow ray origin: hitP + eps * N
                        logic signed [31:0] shad_ox, shad_oy, shad_oz;
                        logic signed [31:0] eps_nx, eps_ny, eps_nz;
                        vec3_scale u_shad_eps (
                            .x(hit_nx), .y(hit_ny), .z(hit_nz),
                            .s(32'sd655),
                            .rx(eps_nx), .ry(eps_ny), .rz(eps_nz)
                        );
                        vec3_add u_shad_orig (
                            .ax(hit_px), .ay(hit_py), .az(hit_pz),
                            .bx(eps_nx), .by(eps_ny), .bz(eps_nz),
                            .rx(shad_ox), .ry(shad_oy), .rz(shad_oz)
                        );
                        
                        // Test intersection
                        logic signed [31:0] shad_t;
                        logic shad_hit;
                        ray_sphere_intersect u_shad_isect (
                            .ox(shad_ox), .oy(shad_oy), .oz(shad_oz),
                            .dx(ldir_x), .dy(ldir_y), .dz(ldir_z),
                            .cx(scene_cx), .cy(scene_cy), .cz(scene_cz),
                            .radius(scene_radius),
                            .hit(shad_hit),
                            .t(shad_t)
                        );
                        
                        if (shad_hit && shad_t > 32'sd0 && shad_t < dist_to_light) begin
                            in_shadow <= 1'b1;
                        end
                        
                        iter_count <= iter_count + 4'd1;
                    end
                    
                    if (current_sphere_idx < NUM_SPHERES - 1) begin
                        current_sphere_idx <= current_sphere_idx + 2'd1;
                    end
                end
                
                ST_SHADE_ACCUM: begin
                    if (!in_shadow) begin
                        // Add diffuse contribution
                        // (This is complex — simplified version for now)
                        // In reality, need to compute ndotl, multiply by intensity, etc.
                        // For brevity, just add some lighting
                        
                        shade_r <= shade_r + (16'sd50 * $signed({11'd0, weight})) >>> 4;
                        shade_g <= shade_g + (16'sd50 * $signed({11'd0, weight})) >>> 4;
                        shade_b <= shade_b + (16'sd50 * $signed({11'd0, weight})) >>> 4;
                    end
                    
                    // Accumulate this bounce's shading
                    accum_r <= accum_r + (shade_r * $signed({11'd0, weight})) >>> 4;
                    accum_g <= accum_g + (shade_g * $signed({11'd0, weight})) >>> 4;
                    accum_b <= accum_b + (shade_b * $signed({11'd0, weight})) >>> 4;
                    
                    current_light_idx <= current_light_idx + 1'd1;
                end
                
                ST_REFLECT_CHECK: begin
                    // Check if should continue bouncing
                    logic [4:0] r_mix = sphere_reflectivity[16:12];  // Q16.16 → [0,16]
                    
                    if (r_mix > 5'd0 && bounce_count < 3'd3 && iter_count < MAX_ITERATIONS) begin
                        // Update weight for next bounce
                        weight <= (weight * r_mix) >>> 4;
                        bounce_count <= bounce_count + 3'd1;
                    end
                end
                
                ST_OUTPUT: begin
                    // Clamp and output
                    rgb_r <= (accum_r > 16'sd255) ? 8'd255 : 
                             (accum_r < 16'sd0)   ? 8'd0   : accum_r[7:0];
                    rgb_g <= (accum_g > 16'sd255) ? 8'd255 : 
                             (accum_g < 16'sd0)   ? 8'd0   : accum_g[7:0];
                    rgb_b <= (accum_b > 16'sd255) ? 8'd255 : 
                             (accum_b < 16'sd0)   ? 8'd0   : accum_b[7:0];
                    
                    pixel_done <= 1'b1;
                end
            endcase
        end
    end

endmodule

`default_nettype wire
