# Raytracer Project Plan (Q8.4, LUT Scene + Lights, No RAM)

This plan turns `pipeline.md` and `connections.md` into a complete implementation path using:
- Q8.4 fixed point (`signed [11:0]`)
- no frame buffer
- no runtime scene RAM
- scene and lights encoded as compile-time LUT constants generated by Python

---

## 1) Final Architecture

### Dataflow (one pixel at a time)
1. `cameraRayGen`: converts VGA pixel `(x,y)` to ray origin `O` and direction `D`.
2. `sceneStreamer`: iterates sphere primitives from LUT.
3. `raySphereIntersect`: computes hit flag + candidate `t` for each object.
4. `hitReducer`: keeps nearest positive `t` across all objects.
5. `normalStage`: computes hit point and surface normal.
6. `lightStage`: evaluates lights from LUT and accumulates diffuse/specular.
7. `colorPack`: outputs RGB to VGA.

Pipeline style: valid/ready streaming. One pixel enters each cycle after fill latency.

---

## 2) Scene and Light Representation (No RAM)

Use generated `case` LUT in combinational logic:
- object count constant
- object fields by index

For sphere objects (Q8.4):
- `cx, cy, cz`
- `radius`
- `colorR, colorG, colorB` (8-bit each)
- `reflectivity` (Q8.4)

For light objects (Q8.4):
- `lx, ly, lz`
- `colorR, colorG, colorB` (8-bit each)
- `intensity` (Q8.4)

No BRAM needed for small scenes (e.g., 4–16 spheres and 1–8 lights).

---

## 3) Python Scene Compiler

Input: JSON scene file, example:
```json
{
  "spheres": [
    {"center": [0.0, 0.0, 4.0], "radius": 1.0, "color": [255, 0, 0], "reflectivity": 0.25}
  ],
  "lights": [
    {"position": [2.0, 3.0, 1.0], "color": [255, 240, 220], "intensity": 1.0}
  ]
}
```

Output: `implementation/scene-lut.svh`
- localparams for sphere and light counts
- `sceneSphereGet(idx, ...)`
- `sceneLightGet(idx, ...)`

This gives software-driven authoring with hardware-static data.

---

## 4) Module Breakdown

## Fixed/Q8.4 Primitive Layer
- `fixedPointAdd`
- `fixedPointSub`
- `fixedPointMul`
- `fixedPointDiv`
- `fixedPointCompare`
- `fixedPointSqrt` (initial placeholder, then iterative)
- `fixedPointDot`
- `fixedVec3Sub`
- `fixedVec3Add`
- `fixedVec3ScalarMul`
- `fixedVec3Normalize` (or skip normalize first pass)

## Geometry Layer
- `raySphereIntersect`
- later: `rayPlaneIntersect`, `rayTriangleIntersect`

## Pipeline/Control Layer
- `cameraRayGen`
- `sceneStreamer`
- `hitReducer`
- `normalStage`
- `lightStage`
- `raytracerTop`

---

## 5) Integration Order (Do This Next)

1. **Lock numeric format** (already Q8.4).
2. **Make sphere-only MVP**: one sphere hardcoded in LUT.
3. **Implement `raySphereIntersect`** and verify with testbench.
4. **Implement nearest-hit reducer** for N spheres.
5. **Implement normal stage** using hit point and sphere center.
6. **Implement light stage** with per-light diffuse accumulation.
7. **Connect to VGA pixel path** (reuse existing VGA timing block).
8. **Add reflectivity + one bounce** (optional phase 2).

---

## 6) Lighting Model (Q8.4)

Per light:
- $L = lightPos - hitPos$
- $NdotL = \max(0, N \cdot L)$
- `diffuseQ = clamp((NdotL * intensity) >> 4, 0, 16)`
- `accColor += ((baseColor * lightColor) >> 8) * diffuseQ >> 4`

Then clamp each RGB channel to `[0,255]`.

---

## 7) Verification Strategy

- Unit tests (Verilator):
  - fixed primitives (mul/div/dot)
  - sphere intersection edge cases (`Δ<0`, tangent, two roots)
  - light accumulation (`NdotL <= 0`, clamp behavior)
- Integration tests:
  - 1 sphere centered view (golden center pixel hit)
  - multiple spheres nearest-hit correctness
- Visual regression:
  - render to PPM from simulation and compare checksums

---

## 8) Resource Strategy for Memory-Limited Target

- No framebuffer, chase-the-beam only.
- Scene LUT in logic (small N).
- Reuse arithmetic blocks across cycles if area constrained.
- Optional compile flag:
  - `fastParallel=1`: more DSP/LUT, lower latency
  - `areaSave=1`: shared arithmetic, smaller area

---

## 9) Immediate Deliverables in Repository

- `tools/scene-compiler.py` (JSON -> LUT header with spheres and lights)
- `implementation/scene-lut.svh`
- `implementation/scene-streamer.sv`
- `implementation/ray-sphere-intersect.sv`
- `implementation/raytracer-top.sv`

These are scaffolded now so placeholders can be replaced incrementally.

---

## 10) Open TODO Checklist

- [ ] Implement `raySphereIntersect` using primitives in [implementation/ray-sphere-intersect.sv](implementation/ray-sphere-intersect.sv)
- [ ] Implement `fixed_point_sqrt` in [implementation/primitives.v](implementation/primitives.v)
- [ ] Implement `fixed_point_recip` in [implementation/primitives.v](implementation/primitives.v)
- [ ] Implement `fixed_vec3_normalize` in [implementation/primitives.v](implementation/primitives.v)
- [ ] Add nearest-hit reducer stage and wire into [implementation/raytracer-top.sv](implementation/raytracer-top.sv)
- [ ] Replace single-light placeholder with full `SCENE_LIGHT_COUNT` accumulation in [implementation/raytracer-top.sv](implementation/raytracer-top.sv)
- [ ] Add camera ray generation from `pixel_x/pixel_y` in [implementation/raytracer-top.sv](implementation/raytracer-top.sv)
- [ ] Add Verilator unit tests for primitives and ray/sphere edge cases
